### 라우팅

- **Selecting process ⇒ path**
- (csr)은 Spa가 많다.  (csr에서는 path가 하나였는데)
- ssr는 페이지가 여러 개 되면서 path가 여러개로 나뉘게 됨
- path가 여러 개이기 때문에, 셀렉팅을 해야 함
- **서버사이드 렌더링의 핵심은 여러개의 path를 가진다.**

### 라우팅 방식

- 명시적 라우팅  (path와, 컴포넌트 명시적 구현)
    - React-router (csr)
    - <Route path=’/’ components = {<Home/>/>
- 코드기반 라우팅
    - Express (node.js)
    - app.get(’/’, (req.res) ⇒ { res.send(’Hompage content’)
    - 서버에서 get 코드를 기반
- 데코레이터기반 라우팅
    - Nest JS
    - MVC 의 C
    - @get()
    - find all() : string
    - return ~~~
- 파일구조 기반 라우팅
    - pages/about.jsx
    - 사용자가 [localhost:3000](http://localhost:3000)/aobut ⇒  about.jsx를 보여줌
    - **굉장히 직관적임** (이전버전, 페이지라우터)
    - app / about / pages.tsx
    - 지금은 앱라우팅
    - 페이지라우터가 직관적이지만, why 앱 라우터?
    - about 폴더안에 page 뿐만아니라, layout.tsx 같은 파일도 필요했음
    - error.tsx, loading.tsx , template.tsx
    - 자주사용하는 컴포넌트 구조를 추상화 해둠(사용하기 쉽도록)
    - path별로 나눠서 js 응답 (응답하는 파일 자체가 줄어듬)
    - 코드 스플리팅을 자동으로 구현해줌
    - colocation (같은맥락,코드들 같은 위치에 두자 (유지보수목적))
    - 명확한 프로젝트구조 (장점)

### why jsx

- 자바스크립트 코드 안에서 HTML문법을 그대로 쓸 수 있게 해주는 도구
- 자바스크립트 로직안에 UI(HTML) 직관적으로 표현하기 위해 JSX 만듦
- (과거엔, HTML, js 철저히 분리하였으나, 복잡해지다 보니, 기능별로(컴포넌트로) 묶어서 관리하자)
- jsx → (바벨) → js
- html태그와 유사함 (이해하기 쉬움)
- jsx 사용하지 않고도, 리액트 사용 가능하다.

```jsx
// JSX
const element = <h1 className="title">Hello, World!</h1>;
// JS
const element = React.createElement(
  'h1',
  { className: 'title' },
  'Hello, World!'
);
```

### Element

- React앱의 가장 작은 구성 요소
1. React element → DOM element 소속이됨
2. 브라우저가 React element들을 DOM element로 인식한다
3. DOM element로 인식된 React element들을 렌더링한다

- React element
- 보통 div tag (’root’ element)

```jsx
// 예전방식
<div id = 'root'> </div>
const elemnet = <h1> hello </h1>;
ReactDOM.render(element, document.getElementById('root'));  

//최신버전
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
const element = <h1>hello</h1>;
root.render(element);
// 동시성 렌더링 지원
```

> ReactDOM → render 메서드 실행
> 

> element를 → div의 id가 ‘root’인 곳에 번역해서 넣음
> 

> virtual DOM ⇒ Real DOM로 넣음 (마운트)
> 
- ReactDom은 달라진 부분만 업데이트 한다.

**“Vue에서 mount하는 것과 개념적으로 같다”**

### Componets and Props

- 컴포넌트는 props를 인자로 받아, element를 리턴하는 함수이다.
- Function component
    - 2가지 기준
    - props를 인자로 받는다, react element를 return한다.
- 클래스형 컴포넌트 (요즘 안씀)

### Rendering component

- 하나의 싱글 오브젝트가 props이다.

### composing component

- 추상화

### useState

- [변수, 함수] = useState(’’)
    - userState 내부에 [안의변수, 함수] 이렇게 되어서 각각 할당된다 이해하면 됨
- 변수는 (유저가 수정했거나) 했을 때 변경이 자동으로 반영 안됨 (html에)
- state 안의 글자는 바뀌면 → html이 재 렌더링이 됨
- 리액트에서 State쓰는 이유 = 리액트는 직접 DOM을 만지지 않음
- 컴포넌트 → Virtual DOM → 실제 DOM
- 변경이 자주 되는것만 State하면 된다 (변경 안되는건 그냥 변수로 하면 된다)
1. **state가 변함**
2. 리액트가 “아! 데이터가 변했군 → 컴포넌트 다시 실행해야겠다!”
3. 컴포넌트 함수를 다시 호출해서
    
    **새 Virtual DOM**을 만듦
    
4. 이전 Virtual DOM과 비교(diff)
5. 달라진 부분만 진짜 DOM에 반영 (업데이트)
6. 화면이 바뀜

이 과정 전체를 “재렌더링”이라고 부름.

```jsx
function App() {
  const [count, setCount] = useState(0)

  return (
    <>
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
    </>
  )
}
```

> onClick 하면 → setCount함수를 실행시켜라 → 이 함수는 뭐냐면 ( count를 → count +1로 바꿔라) → 출력 count is {count}
> 

### useRef

- state와 달리 배열을 반환하지 않음 (setter함수 x)
- 재렌더링 x / 변경해도 화면 변화 x / DOM접근 가능

```jsx
  const myref = useRef(1)
<button onClick = {() => myref.current = myref.current + 1}>
  myref is {myref.current}
</button>
```

> () ⇒  는 fucntion() { } 와 같다..   return도 생략되어 있음 (화살표 함수)
> 
> 
> 복잡해지지만, 따로 함수 빼서 사용
> 
> - 다른 요소가 실행되어 렌더링 되면 (그때 ref로 변경된 값이 업데이트 됨)

### useEffect

- 함수형 컴포넌트에서 부수효과(side effect) 처리하기 위해 사용
    - 데이터가져오기/api호출등 비동기작업/구독취소 등에 사용
- 렌더링 될 때마다 매번 실행됨
- 끝에 [] dependency array 넣으면 (처음이랑, array 값 바뀌면 실행됨)
- 빈 배열로 놔두면 (마운트될때만) 처음 연결될 때만 실행된다.

```jsx
useEffect(
  () => {
    // A. 실행할 작업 (Effect)
    return () => {
      // B. 정리 작업 (Cleanup)
    };
  },
  [] // C. 의존성 배열 (Dependency Array)
);
```

> useEffect 구조
> 

```jsx
mport { useState, useEffect } from "react";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 1. [Mount] 컴포넌트가 처음 나타날 때 딱 1번 실행됨 (뒤에 []가 있어서)
    console.log("타이머 시작!");
    const interval = setInterval(() => {
      // 1초마다 실행되는 코드
      setCount((prevCount) => prevCount + 1);
    }, 1000);

    // 2. [Unmount] 컴포넌트가 사라질 때 실행됨 (뒷정리)
    return () => {
      clearInterval(interval); // 타이머를 멈춤 (메모리 누수 방지)
      console.log("타이머 종료 및 청소 완료 (cleaned up)");
    };
  }, []); // 의존성 배열이 비어있으므로 '처음 한 번만' 실행

  return <p>Timer : {count}</p>;
}

export default Timer;
```

> setCount (현재값 ⇒ 현재값 +1 )
> 

> setCount(count+1) 안쓰는 이유는,
> 
- useEfeect는 처음에 딱 한번만 실행 ([] 때문에)
- 그때 setInterval 만들어지는데 →

### SetInterval

- 1초마다 실행되는 코드
- useEffect자체는 1번 실행되기 때문에
- count르 쓰면  0, 1만 반복하게 됨
- 그래서 이전 값 업데이트하는 함수 사용